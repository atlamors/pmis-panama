# CSS & Tailwind Isolation Strategy

## Problem Statement

In a multi‑MFE Angular environment, CSS collisions are a high risk. Hosts and remotes may accidentally share class names, tokens, or reset styles, leading to broken UIs. We need a strategy that guarantees isolation while keeping developer experience sane.

## Chosen Strategy

We’ve adopted per‑MFE Tailwind builds with host prefixing only.

- **Host**
  - Tailwind is configured with a `host-` prefix.
  - All utilities are namespaced (e.g., `host-p-4`, `host-bg-surface`).
  - This ensures the host shell styles can never override or collide with remote styles.
- **Remotes**
  - Tailwind is configured with no prefix.
  - Teams use standard Tailwind classes (`p-4`, `bg-surface`, `flex-col`).
  - This keeps developer experience simple and friction‑free.

### Why This Balance?

- **Prefixing everywhere is overly burdensome** (`sched:p-4` vs `p-4`).
- **Remotes don’t share stylesheets**, so they’re already isolated.
- **Host is the integration layer**, so it shoulders the burden of safety.

## CSS Delivery

### Production

- Each remote outputs a hashed `style.css` (e.g., `style.abc123.css`).
- A post‑build script writes `assets/assets.json` containing the CSS filenames.
- Host fetches this manifest at runtime and injects `<link>` tags.
- Example manifest:

```json
{ "css": ["style.abc123.css"] }
```

### Development

- Tailwind CLI writes to `src/assets/style.css` via `tw:watch`.
- Host attempts to load `assets/assets.json`; if missing, falls back to `assets/style.css`.

## Benefits

- Host shell is protected from bleed‑through by namespacing.
- Remotes stay developer‑friendly (vanilla Tailwind).
- Works seamlessly across dev and prod with minimal boilerplate.

## Risks & Tradeoffs

- Slight duplication of utilities across builds (acceptable).
- Requires runtime `<link>` injection (negligible performance impact with CDN caching).
- Teams must ensure their remote actually outputs `style.css` or manifest will fail.


